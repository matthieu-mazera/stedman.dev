---
layout: post
title: Make the Jump from Jekyll to JavaScript
---

With the recent addition of [Actions](https://github.com/features/actions) to GitHub's product lineup, we now have the ability to create a *100% Pure, Unfiltered&trade;* JavaScript alternative to Jekyll (and Ruby) in GitHub Pages. This is a big deal. Really.

## Back story

[GitHub Pages](https://pages.github.com/), for the uninitiated, allows you to create websites from the source code stored in a GitHub repo. There are no databases to set up, no servers to provision, and no file transfers. Better yet, it allows you to transform plain text into static websites and blogs with the help of Jekyll.

[Jekyll](https://jekyllrb.com/) is a pretty sweet setup. It's been around quite awhile, it's battle tested, and it's simple enough for beginners yet powerful enough for advanced users. Unfortunately, setting it up and running it locally for development purposes has been a chore for folks not accustomed to working with Ruby. Beyond the context switch to another language's syntax and grammar, getting a Ruby environment set up just right can be a challenge (especially on Windows). Sure, we can now spin up a Docker container with Ruby and Jekyll, but is it worth it?

Since GitHub Pages arrived in 2008, the dream of running a static site generator on Pages with all the hooks and privileges of Jekyll has been just out of reach. My friends, it's 2020 and the pieces have finally fallen into place. Let's do this.

### Scope

This article will cover the bare essentials of migrating from Jekyll to JavaScript. And for the sake of expediency, we'll assume you are using the [default Jekyll directory structure](https://jekyllrb.com/docs/structure/):

```shell
..
├── _data
├── _includes
│   ├── footer.html
│   └── header.html
├── _layouts
│   ├── default.html
│   └── post.html
├── _posts
├── _site
├── about
│   └── index.html
├── assets
│   ├── css
│   ├── images
│   └── js
├── index.html
...
```

## Set up the static site generator

It took awhile for someone to distill the essence of Jekyll into JavaScript. With [Eleventy](https://11ty.dev), Zach Leatherman ([@zachleat](https://twitter.com/zachleat)) has really distilled, bottled, and shipped it. Oh, and did I mention that it's fast? I'll skip the pitch here and let the experts do the talking.

* [Paul Lloyd: Turn Jekyll Up to Eleventy](https://24ways.org/2018/turn-jekyll-up-to-eleventy/)
* [Dave Rupert: What I Like About Eleventy](https://daverupert.com/2019/08/what-i-like-about-eleventy/)

### Install and configure

Install Eleventy as a `devDependency`.

```shell
npm install --save-dev @11ty/eleventy
```

Add the `.eleventy.js` config file with the following contents. See the [Eleventy documentation](https://www.11ty.dev/docs/config/) for more details.

```js
module.exports = (eleventyConfig) => {
  // Copy the "assets" directory to the compiled "_site" folder.
  eleventyConfig.addPassthroughCopy('assets');

  return {
    dir: {
      input: './',
      output: './_site',
      layouts: './_layouts',
    },
    templateFormats: [
      'html',
      'liquid',
      'md',
      'njk',
    ],
  };
};
```

On the output side, notice that we are maintaining parity with Jekyll's deployment, using the `_site` directory for our output.

Add the following scripts section to `package.json`. We'll need the `build` section for our deployment later.

```json
  "scripts": {
    "clean": "rm -rf ./_site",
    "build": "npm run clean && eleventy",
    "start": "eleventy --serve --watch"
  },
```

* **clean** empties out the deployment directory
* **build** cleans the deploy directory and builds the site with Eleventy
* **start** runs Eleventy in dev mode with live browser refreshes

## Set up GitHub deployments

Now for the real magic sauce, [GitHub Actions](https://docs.github.com/en/actions)-style.

1. Open a browser to your repo and then select the **Actions** tab.
2. Tap on the **New workflow** button.
3. Tap on the **Set up a workflow yourself** button.
4. In the **{repo_name}/.github/workflows/`main.yml`** field, enter "`eleventy_build.yml`".
5. Into the **Edit new file** textarea, cut and paste the following:

    {% raw %}

    ```yaml
    name: Eleventy Build

    # Controls when the action will run. Triggers the workflow on push or pull request
    # events but only for the master branch
    on:
      push:
        branches: [ master ]

    # A workflow run is made up of one or more jobs that can run sequentially or in parallel
    jobs:
      # This workflow contains a single job called "build"
      build:
        # The type of runner that the job will run on
        runs-on: ubuntu-latest

        # Steps represent a sequence of tasks that will be executed as part of the job
        steps:
        # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
        - uses: actions/checkout@v2

        - name: Setup Node.js environment
          uses: actions/setup-node@v1.4.1

        - name: Install packages
          run: npm ci

        - name: Run npm build
          run: npm run build

        - name: Deploy to gh-pages
          uses: peaceiris/actions-gh-pages@v3
          with:
            deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}
            publish_dir: ./_site
    ```

6. Tap the **Start commit** button.

The workflow script should be fairly self-descriptive. See that `${{ secrets.ACTIONS_DEPLOY_KEY }}` line near the end of the workflow? We need to add deploy keys to GitHub before attempting a deployment.

{% endraw %}

The following instructions were cribbed from a third-party [GitHub Actions for GitHub Pages](https://github.com/marketplace/actions/github-pages-action#%EF%B8%8F-create-ssh-deploy-key) page. Please check that site for updates before proceeding as these instructions may have changed.

1. Generate a SSH key locally to use as your deploy key.

    ```shell
    ssh-keygen -t rsa -b 4096 -C "$(git config user.email)" -f gh-pages -N ""
    # You will get 2 files:
    #   gh-pages.pub (public key)
    #   gh-pages     (private key)
    ```

2. Open a browser to your repo and select the **Settings** tab.

3. Select **Deploy keys** from the left menu.

    1. Tap the **Add deploy key** button.
    2. In the **Title** field, enter "`Public key of ACTIONS_DEPLOY_KEY`".
    3. In the **Key** field, cut and paste the contents of your `gh-pages.pub` SSH key file made in step 1 above.
    4. Check the **Allow write access** box.
    5. Tap the **Add key** button.

4. Select **Secrets** from the left menu.

    1. Tap the **Add a new secret** link.
    2. In the **Name** field, enter "`ACTIONS_DEPLOY_KEY`".
    3. In the **Value** field, cut and paste the contents of your `gh-pages` SSH key file from step 1 above.
    4. Tap the **Add secret** button.

5. To initiate a deployment, commit/merge to the `master` branch. The first deploy will fail.

6. Go back to the **Settings** tab.

    1. Scroll down to the **GitHub Pages** section.
    2. From the **Source** options, select `gh-pages branch`.

7. Merge some more code into `master` to initiate another deploy.

Congrats. You're done!

## Conclusion

From here on out, you should be able to trigger a fresh build and deploy by:

* working/saving locally, committing, and pushing to `origin master`.
* editing your code at github.com and saving to `master`.

Your updates will deploy to live in mere seconds/minutes. All of this within the environment that you version your code in. How cool is that?

You may celebrate and relax or start writing your next great blog post. Your call.

Oh, and by the way, we only covered the **publish** deployment scenario. With a little ingenuity, I'm sure you could figure out a **draft** publication flow that relies on different build and deploy steps.

Who knows. I may have to look into that myself.
